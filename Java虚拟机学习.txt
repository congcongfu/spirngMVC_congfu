
  Java GC回收机制

 1 ava中，GC的对象是Java堆和方法区（即永久区）
   我们接下来对上面的三句话进行一一的解释：

（1）GC：Garbage Collection 垃圾收集。这里所谓的垃圾指的是在系统运行过程当中所产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不被释放，

可能导致OOM。在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。而在Java中，后台专门有一个专门用于垃圾回收的线程来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，目的在于防止由程序猿引入的人为的内存泄露。

（2）事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：

哪些内存需要回收？

（3）内存区域中的程序计数器、虚拟机栈、本地方法栈这3个区域随着线程而生，线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作，每个栈帧中分配多少内存基本是在类结构确定下来时就已知的。

在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而Java堆和方法区则不同，一个接口中的多个实现类需要的内存可能不同，

一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC关注的也是这部分内存，后面的文章中如果涉及到“内存”分配与回收也仅指着一部分内存。


二、引用计数算法：（老牌垃圾回收算法。无法处理循环引用，没有被Java采纳）

   给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的

  但是，主流的java虚拟机并没有选用引用计数算法来管理内存，其中最主要的原因是：它很难解决对象之间相互循环引用的问题。

  引用和去引用伴随加法和减法，影响性能 ，致命的缺陷：对于循环引用的对象无法进行回收


三、根搜索算法：

1、根搜索算法的概念：

　它的处理方式就是，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。

  2、可达性分析：

 我们刚刚提到，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。我们在后面介绍标记-清理算法/标记整理算法时，也会一直强调从根节点开始，对所有可达对象做一次标记，那什么叫做可达呢？这里解释如下：

可达性分析：

　　从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连（用图论的概念来讲，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

3、根（GC Roots）：

说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：

1、栈（栈帧中的本地变量表）中引用的对象。

2、方法区中的静态成员。

3、方法区中的常量引用的对象（全局变量）

4、本地方法栈中JNI（一般说的Native方法）引用的对象。

  注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。

在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法。

这三种算法都扩充了根搜索算法，不过它们理解起来还是非常好理解的。


四、标记-清除算法：

  1、标记清除算法的概念：

  标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。

因此，未被标记的对象就是未被引用的垃圾对象；然后，在清除阶段，清除所有未被标记的对象。

2、标记-清除算法详解：

 它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。

  标记）：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。 清除）：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。

也就是说，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。


疑问：为什么非要停止程序的运行呢？

答：

这个其实也不难理解，假设我们的程序与GC线程是一起运行的，各位试想这样一种场景。

  假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象。但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段。

因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。

上面的结果当然令人无法接受，我们刚new了一个对象，结果经过一次GC，忽然变成null了，这还怎么玩？



3、标记-清除算法的缺点：

（1）首先，它的缺点就是效率比较低（递归与全堆对象遍历），导致stop the world的时间比较长，尤其对于交互式的应用程序来说简直是无法接受。试想一下，如果你玩一个网站，这个网站一个小时就挂五分钟，你还玩吗？

（2）第二点主要的缺点，则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，

这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。

五、复制算法：（新生代的GC）

  复制算法的概念：

将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

与标记-清除算法相比，复制算法是一种相对高效的回收方法

不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）


复制算法的最大的问题是：空间的浪费

     复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，这个太要命了。

所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。

现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块比较大的Eden空间和两块较小的Survivor空间，

每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，

也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。

当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代。



六、标记-整理算法：（老年代的GC）

引入：

    如果在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选中这种算法。

概念：

    标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，

而是将所有的存活对象压缩到内存的一端；之后，清理边界外所有的空间。

    标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。

整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。
 
    标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。

  但是，标记/整理算法唯一的缺点就是效率也不高。不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。

因此，要想防止内存泄露，最根本的办法就是掌握好变量作用域，


七、分代收集算法：（新生代的GC+老年代的GC）

   当前商业虚拟机的GC都是采用的“分代收集算法”，这并不是什么新的思想，只是根据对象的存活周期的不同将内存划分为几块儿。一般是把Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。

   少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。

   大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。

注：老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代。
 
   新生代里的对象存活率较低比较适合使用复制算法，划分好两块区域 大概是8:1的划分 付出10%的内存浪费。

   对于大量存活的老年代使用标记/整理算法，标记存活的对象，删除未被标记的对象，然后对内存进行整理。

 注：老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代。


 八、可触及性：

   所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义。

  可触及的：

　　从根节点可以触及到这个对象。

    　　其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。

  可复活的：

　　  一旦所有引用被释放，就是可复活状态

　  　因为在finalize()中可能复活该对象

  不可触及的：

　　  在finalize()后，可能会进入不可触及状态

　　  不可触及的对象不可能复活

    　 　要被回收。




partyid=565613386&linkman=残山剩水&mobilenumber=18657134758&bookkeepingAllow=1&partyid=565613386&site=%E7%89%A9%E6%B5%81%E4%BA%A7%E4%B8%9A&bookkeepingAllow=on&taxpayeridentificationnum=123456789874522&companycode=%E6%B0%B4%E7%94%B5%E8%B4%B9&taxdiskcode=%E8%BF%94%E5%9B%9E%E5%8F%91&taxfilingdiskcode=%E6%9B%B4%E5%A5%BD%E7%9C%8B%E8%A7%84%E8%8C%83%E5%92%8C%E6%88%90%E5%8A%9F&accountManager=%E8%BF%94%E5%9B%9E%E6%9B%B4%E5%A5%BD&detailaddress=%E5%A3%AB%E5%A4%A7%E5%A4%AB%E6%92%92%E6%97%A6&description=%E6%9B%B4%E5%A5%BD%E6%B3%95%E5%9B%BD%E6%81%A2%E5%A4%8D&organization=残山剩水&partyname=NatureMan&detailaddress=士大夫撒旦&telephonenum=































